# -*- coding: utf-8 -*-
"""Minimum_Internal_Constraints.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1UmpEUKI5pXn7zRhltDaZf0RvoAIF8WOL

# Definition of the network properties.
"""

#Import modules.
import numpy as np
import sympy as sp
import sys
from sympy import symbols, diff
from numpy.linalg import multi_dot
import math
import matplotlib.pyplot as plt
from matplotlib.patches import Ellipse

n = 16 #number of measuremens.
v = 5 #number of network nodes.
d = 3 #imperfections : position and orientation = 2+1 =3
m = 2*v-d #number of unknown parameters.
r = n - m #degrees of freedom.
c = r + m #number of observation equations.

np.set_printoptions(suppress=True,threshold=np.inf,linewidth=300,precision=15) 

print("{} observation equations must be created".format(c))
print('-'*40)
print("The design matrix A has dimensions of {}x{}".format(n,2*v))
print("The constraint matrix C has dimensions of {}x{}".format(d,2*v))
print("The weight matrix P has dimensions of {}x{}".format(n,n))

#Matrices of measurements and standard errors.
l = np.array([64.1902,50.8882,32.4675,60.7616,26.2679,43.1958,92.6467,29.5762,106.2276,116.6508,112.9705,64.1595,490.249,220.725,791.552,659.535]) #array which includes all measurements. (angles+lengths)
noa = 12 #number of angles 
sigma_1 = np.array([25]*noa) #the standard error is in cc!
sigma_2 = np.array([0.012]*(l.shape[0]-noa)) #the standard error is in meters!
sigma = np.concatenate((sigma_1,sigma_2))

#Temporary coordinates of network nodes.
x = np.array([1586.537,2075.094,2222.679,1449.130,1688.320])
y = np.array([937.235,896.541,354.801,522.664,741.395])

#Create a vector X with the coordinates of all network nodes.
X = np.zeros(shape=(2*x.shape[0]))
j=0
for i in range(2*x.shape[0]):
  if i%2==0:
    X[i]=x[j] 
  else:X[i]=y[j] 
  if i%2!=0:j+=1 
X

#Create the necessary variables.
b_jik, a_ik, a_ij = symbols("b_jik, a_ik, a_ij ")
y_i,y_j,y_k = symbols("y_i,y_j,y_k")
x_i,x_j,x_k = symbols("x_i,x_j,x_k")
S_ij,S_ik = symbols("S_ij,S_ik")
dx_i,dx_j,dx_k = symbols("dx_i,dx_j,dx_k")
dy_i,dy_j,dy_k = symbols("dy_i,dy_j,dy_k")

#Auxiliary indices.
jj = np.array([2,5,1,5,4,5,3,5,1,4,3,2,2,5,3,3])-1
ii = np.array([1,1,4,4,3,3,2,2,5,5,5,5,1,1,4,5])-1
kk = np.array([5,4,5,3,5,2,5,1,2,1,4,3])-1

eqs = np.empty(shape=(n,), dtype=object)

#Linearized angle equations.
angle_eq = ((y_j-y_i)/S_ij**2 - (y_k-y_i)/S_ik**2)*dx_i + ((x_k-x_i)/S_ik**2 - (x_j-x_i)/S_ij**2)*dy_i - dx_j*(y_j-y_i)/S_ij**2 + dy_j*(x_j-x_i)/S_ij**2 + dx_k*(y_k-y_i)/S_ik**2 - dy_k*(x_k-x_i)/S_ik**2
angle_eq

#Linearized distance equations.
dist_eq = -(x_j-x_i)/S_ij*dx_i-dy_i*(y_j-y_i)/S_ij+(x_j-x_i)/S_ij*dx_j+dy_j*(y_j-y_i)/S_ij
dist_eq

def finda(dx,dy,a):
  '''This function calculates the true value of an azimuth angle'''
  if dx>0:
    if dy>0:return 200*a/math.pi 
    if dy==0:return 100
    if dy<0:return 200+200*a/math.pi
  if dx<0:
    if dy>0:return 400+200*a/math.pi 
    if dy==0:return 300
    if dy<0:return 200+200*a/math.pi  
  if dx==0:
    if dy>0:return 0
    if dy==0:return print("Division by 0!")
    if dy<0:return 200

"""# Creation of design matrix Α."""

#Construction of the 16 observation equations.
for i in range(eqs.shape[0]):
  Sij = np.sqrt((x[jj[i]]-x[ii[i]])**2)+np.sqrt((y[jj[i]]-y[ii[i]])**2)
  if i<=noa-1:
    Sik = np.sqrt((x[kk[i]]-x[ii[i]])**2)+np.sqrt((y[kk[i]]-y[ii[i]])**2)
    eqs[i]=angle_eq.subs([(x_i,x[ii[i]]),(x_j,x[jj[i]]),(x_k,x[kk[i]]),(y_i,y[ii[i]]),(y_j,y[jj[i]]),(y_k,y[kk[i]]),(S_ij,Sij),(S_ik,Sik),
                        (dx_i,symbols('dx_{}'.format(ii[i]))),
                        (dx_j,symbols('dx_{}'.format(jj[i]))),
                        (dx_k,symbols('dx_{}'.format(kk[i]))),
                        (dy_i,symbols('dy_{}'.format(ii[i]))),
                        (dy_j,symbols('dy_{}'.format(jj[i]))),
                        (dy_k,symbols('dy_{}'.format(kk[i])))
                        ])*636620
  else:
    eqs[i] = dist_eq.subs([(x_i,x[ii[i]]),(x_j,x[jj[i]]),(y_i,y[ii[i]]),(y_j,y[jj[i]]),(S_ij,Sij),
                        (dx_i,symbols('dx_{}'.format(ii[i]))),
                        (dx_j,symbols('dx_{}'.format(jj[i]))),
                        (dy_i,symbols('dy_{}'.format(ii[i]))),
                        (dy_j,symbols('dy_{}'.format(jj[i]))),
                                                ])

#Create auxiliary vector.
dx_0,dy_0,dx_1,dy_1,dx_2,dy_2,dx_3,dy_3,dx_4,dy_4 = symbols('dx_0,dy_0,dx_1,dy_1,dx_2,dy_2,dx_3,dy_3,dx_4,dy_4')

DX = [dx_0,dy_0,
      dx_1,dy_1,
      dx_2,dy_2,
      dx_3,dy_3,
      dx_4,dy_4]

DX

#Differentiation of each equation with each one of the unknown parameters and creation of design matrix Α.  
A = np.zeros(shape=(n,m+d))
for i in range(0,n):
  for j in range(0,m+d):
      A[i,j] = diff(eqs[i],DX[j])
print('Array A is:\n')
print(A)

"""# Creation of matrix of the calculated values."""

#Creation of matrix of the calculated values.
delta_l = np.zeros(shape=(n,))

for i in range(n):

  if i<=noa-1: #If its a angle equation.
    
    div1 = (x_k-x_i)/(y_k-y_i)
    div2 = (x_j-x_i)/(y_j-y_i)

    d1=float(div1.subs([(x_i,x[ii[i]]),(x_j,x[jj[i]]),(x_k,x[kk[i]]),(y_i,y[ii[i]]),(y_j,y[jj[i]]),(y_k,y[kk[i]])]))
    d2=float(div2.subs([(x_i,x[ii[i]]),(x_j,x[jj[i]]),(y_i,y[ii[i]]),(y_j,y[jj[i]]),(y_k,y[kk[i]])]))

    aik_ = np.arctan(d1)
    aij_ = np.arctan(d2)

    #Azimuth angle calculation.
    deltaX = x_k-x_i
    deltaY = y_k-y_i
    deltaX = float(deltaX.subs([(x_i,x[ii[i]]),(x_j,x[jj[i]]),(x_k,x[kk[i]]),(y_i,y[ii[i]]),(y_j,y[jj[i]]),(y_k,y[kk[i]])]))
    deltaY = float(deltaY.subs([(x_i,x[ii[i]]),(x_j,x[jj[i]]),(x_k,x[kk[i]]),(y_i,y[ii[i]]),(y_j,y[jj[i]]),(y_k,y[kk[i]])]))
    aik=finda(deltaX,deltaY,aik_)

    deltaX = x_j-x_i
    deltaY = y_j-y_i
    deltaX = float(deltaX.subs([(x_i,x[ii[i]]),(x_j,x[jj[i]]),(x_k,x[kk[i]]),(y_i,y[ii[i]]),(y_j,y[jj[i]]),(y_k,y[kk[i]])]))
    deltaY = float(deltaY.subs([(x_i,x[ii[i]]),(x_j,x[jj[i]]),(x_k,x[kk[i]]),(y_i,y[ii[i]]),(y_j,y[jj[i]]),(y_k,y[kk[i]])]))
    aij=finda(deltaX,deltaY,aij_)

    delta_l[i]=(l[i]-aik+aij) #in cc
    while delta_l[i]>399: delta_l[i]-=400
    delta_l[i]=delta_l[i]*10000 #convertion from grad to cc.

  else: #If its a distance equation.
    
    Sij = np.sqrt((x[jj[i]]-x[ii[i]])**2+(y[jj[i]]-y[ii[i]])**2) #distance calculation.
    delta_l[i]=l[i]-Sij #in meters 

delta_l

"""# Calculation of the constraint matrix C."""

#Coordinate point transformation from the origin of the coordinate reference system to the cog of the network.
x_sog = np.sum(x)/5
y_sog = np.sum(y)/5
x = x - x_sog
y = y - y_sog

#Calculation of the constraint matrix.
C=np.zeros(shape=(d,2*v))
i=0
for j in range(2*v):

  if j%2!=0: 
    C[1,j]= 1
    C[2,j]=-x[i]
    i+=1  
    
  if j%2==0:
    C[0,j]= 1
    C[2,j]=y[i]
    
C

"""# Creation of the weight matrix P."""

#Define the a-priori standard error.
sigma_0 = 1 

I = np.identity(n)
P = I*(sigma_0/sigma)**2

print('Array P is:\n')
print(P)

"""#System solution."""

#Calculate the new array with the adjusted coordinate values of all network nodes.
inverted=np.linalg.inv(multi_dot([A.T,P,A])+np.dot(C.T,C))
delta_x=multi_dot([inverted,A.T,P,delta_l])
X_hat = X+delta_x
X_hat

"""#Calculation of the a-priori variance-covariance matrix."""

#Calculate the a-priori variance-covariance matrix of all network nodes.
CCT_inv = np.linalg.inv(np.dot(C,C.T)) 
Cdot=multi_dot([C.T,CCT_inv,CCT_inv,C])
V_x_hat = sigma_0**2*(np.linalg.inv(multi_dot([A.T,P,A])+np.dot(C.T,C))-Cdot)
V_x_hat

"""# Computation of the a posteriori standard error."""

#Calculation of the a-posteriori standard error.
u = np.dot(A,delta_x)-delta_l
sigma_0_hat = np.sqrt(multi_dot([u.T,P,u])/(n-m))
sigma_0_hat

"""#Graphical representation of the error ellipses."""

#Final coordinates of network nodes.
x_hat = np.zeros(shape=(v,))
y_hat = np.zeros(shape=(v,))

j=0
for i in range(0,v):
  x_hat[i] = X_hat[j]
  y_hat[i] = X_hat[j+1]
  if j%2==0:j+=2

#Network edges.
lines_x = np.concatenate((x_hat,np.array([x_hat[0],x_hat[4],x_hat[1],x_hat[4],x_hat[2],x_hat[4],x_hat[3],x_hat[4],x_hat[0],x_hat[3]])))
lines_y = np.concatenate((y_hat,np.array([y_hat[0],y_hat[4],y_hat[1],y_hat[4],y_hat[2],y_hat[4],y_hat[3],y_hat[4],y_hat[0],y_hat[3]])))

def auxfunc(V_xy):

  '''This function takes as argument the variance-covariance submatrix of the corresponding 
  network node or edge, and as output it returns the absolute or relative ellipse properties.'''

  width, height, angle =0,0,0
  
  if (V_xy[0,1]+V_xy[0,0]-V_xy[1,1])!=0: 

    #Define equations for the calculation of the semi-major axis, the semi-minor axis and the orientation of the error ellipse. 
    sigma_x_sq,sigma_y_sq,sigma_xy = symbols('sigma_x_sq,sigma_y_sq,sigma_xy')
    sigma_max_squared = ((sigma_x_sq+sigma_y_sq)+((sigma_x_sq-sigma_y_sq)**2+4*sigma_xy**2)**0.5)/2
    sigma_min_squared = ((sigma_x_sq+sigma_y_sq)-((sigma_x_sq-sigma_y_sq)**2+4*sigma_xy**2)**0.5)/2
    tan_2theta = 2*sigma_xy/(sigma_x_sq-sigma_y_sq)

    #Calculate the length of the semi-major and the semi-minor ellipse axes.
    sigma_max_squared = sigma_max_squared.subs([(sigma_x_sq,V_xy[0,0]),(sigma_y_sq,V_xy[1,1]),(sigma_xy,V_xy[0,1])])
    sigma_min_squared = sigma_min_squared.subs([(sigma_x_sq,V_xy[0,0]),(sigma_y_sq,V_xy[1,1]),(sigma_xy,V_xy[0,1])])
    sigma_u=sigma_max_squared**0.5
    sigma_v=sigma_min_squared**0.5
    width = 2*sigma_u
    height = 2*sigma_v

    #Calculate the orientation of the error ellipse.
    tan_2theta = tan_2theta.subs([(sigma_x_sq,V_xy[0,0]),(sigma_y_sq,V_xy[1,1]),(sigma_xy,V_xy[0,1])])
    theta = math.atan(tan_2theta)*180/(2*math.pi)
    
    #Extract the variances and the covariances from the input matrix.
    sigma_x=V_xy[0,0]**0.5
    sigma_y=V_xy[1,1]**0.5
    sigma_xy=V_xy[0,1]

    #Angle investigation.
    if sigma_x>sigma_y:
      if sigma_xy>0:angle=theta
      if sigma_xy<0:angle=theta+180
    if sigma_x<sigma_y:
      if sigma_xy>0:angle=theta+90  
      if sigma_xy<0:angle=theta+90  
    if sigma_x==sigma_y:
      if sigma_xy>0:angle=45
      if sigma_xy<0:angle=135
 
  return width, height, angle

def ellipse_args(netnodecode1, netnodecode2=9999, V_x_hat=V_x_hat):

  '''This function takes as arguments the specific network node for the calculation of the absolute error ellipse properties, or
  the two network nodes of the corresponding network edge in wich we want to calculate the relative error ellipse arguments. 
  Aditionally this function takes as argument the variance-covariance matrix of the coordinates of all network nodes. As output,
  it extracts the absolute or relative ellipse properties.'''
  
  netnodecode=netnodecode1
  if netnodecode < 5:

    if netnodecode2 == 9999: #If we want to calculate the absolute error ellipse.
      
      #Extract the variance-covariance submatrix of the given network node.
      V_xy = V_x_hat[2*netnodecode:2*netnodecode+2,2*netnodecode:2*netnodecode+2]
      width, height, angle = auxfunc(V_xy)
      return width, height, angle

    elif netnodecode2 < 5: #If we want to calculate the relative error ellipse.
      
      Jrij = np.array([[-1,0,1,0],[0,-1,0,1]])
      Vrig = np.ones(shape=(4,4))

      #Extract the variance-covariance submatrix of the given network edge.
      V_xy1 = V_x_hat[2*netnodecode1:2*netnodecode1+2,2*netnodecode1:2*netnodecode1+2] 
      V_xy2 = V_x_hat[2*netnodecode2:2*netnodecode2+2,2*netnodecode2:2*netnodecode2+2] 
      V1 = V_x_hat[2*netnodecode1:2*netnodecode1+2,2*netnodecode2:2*netnodecode2+2] 
      V2 = V_x_hat[2*netnodecode2:2*netnodecode2+2,2*netnodecode1:2*netnodecode1+2] 
      Vrig=np.asarray(np.bmat([[V_xy1, V1], [V2, V_xy2]]))

      VDrij = multi_dot([Jrij,Vrig,Jrij.T])
      width, height, angle = auxfunc(VDrij)
      return width, height, angle
      
  else: return print("There is no network node with the given code name!")

#Graphical representation of the error ellipses. 

fig=plt.figure(figsize=(15,10))
ax = fig.add_subplot(111, aspect='equal')

#Define plot options.
scalefactor = 1000
ld=1.5
ellcolor = 'red'
ellzorder = 4
pointzorder = 5

#Plot network edges.
plt.plot(lines_x, lines_y, linewidth=0.6, markersize=8, alpha=1)

#Plot network nodes.
plt.scatter(x_hat, y_hat, marker="+", zorder=pointzorder, s=70, c='black')

#Plot nodenames.
nodenames=["A","B","C","D","E"]
for i, txt in enumerate(nodenames):
    ax.annotate(txt, (x_hat[i], y_hat[i]), xytext=(x_hat[i]+5,y_hat[i]+5), zorder=pointzorder)

#Absolute error ellipses of all network nodes.
width, height, angle = ellipse_args(0)
ax.add_artist(Ellipse(xy=X_hat[:2], width=width*scalefactor, height=height*scalefactor, angle=angle, fill=None, alpha=1, linewidth=ld, color=ellcolor, zorder=ellzorder))
width, height, angle = ellipse_args(1)
ax.add_artist(Ellipse(xy=X_hat[2:4], width=width*scalefactor, height=height*scalefactor, angle=angle, fill=None, alpha=1, linewidth=ld, color=ellcolor, zorder=ellzorder))
width, height, angle = ellipse_args(2)
ax.add_artist(Ellipse(xy=X_hat[4:6], width=width*scalefactor, height=height*scalefactor, angle=angle, fill=None, alpha=1, linewidth=ld, color=ellcolor, zorder=ellzorder))
width, height, angle = ellipse_args(3)
ax.add_artist(Ellipse(xy=X_hat[6:8], width=width*scalefactor, height=height*scalefactor, angle=angle, fill=None, alpha=1, linewidth=ld, color=ellcolor, zorder=ellzorder))
width, height, angle = ellipse_args(4)
ax.add_artist(Ellipse(xy=X_hat[8:], width=width*scalefactor, height=height*scalefactor, angle=angle, fill=None, alpha=1, linewidth=ld, color=ellcolor, zorder=ellzorder))

#Relative error ellipses between each station pair.

#Edge AC.
width, height, angle = ellipse_args(0,2)
xy=(X_hat[:2]+X_hat[4:6])/2
xx = np.array([x_hat[0],x_hat[2]])
yy = np.array([y_hat[0],y_hat[2]])
plt.plot(xx, yy, "k--", linewidth=2, markersize=4)
plt.plot((x_hat[0]+x_hat[2])/2,(y_hat[0]+y_hat[2])/2, marker=".", color='red', mec="black", markersize=12, zorder=pointzorder)
ax.add_artist(Ellipse(xy=xy, width=width*scalefactor, height=height*scalefactor, angle=angle, fill=None, alpha=1, linewidth=ld, color=ellcolor, zorder=ellzorder))

#Edge AB.
width, height, angle = ellipse_args(0,1)
xy=(X_hat[:2]+X_hat[2:4])/2
xx = np.array([x_hat[0],x_hat[1]])
yy = np.array([y_hat[0],y_hat[1]])
plt.plot(xx, yy, "k--", linewidth=2, markersize=4)
plt.plot((x_hat[1]+x_hat[0])/2,(y_hat[1]+y_hat[0])/2, marker=".", color='red', mec="black", markersize=12, zorder=pointzorder)
ax.add_artist(Ellipse(xy=xy, width=width*scalefactor, height=height*scalefactor, angle=angle, fill=None, alpha=1, linewidth=ld, color=ellcolor, zorder=ellzorder))

#Edge DB.
width, height, angle = ellipse_args(3,1)
xy=(X_hat[6:8]+X_hat[2:4])/2
xx = np.array([x_hat[3],x_hat[1]])
yy = np.array([y_hat[3],y_hat[1]])
plt.plot(xx, yy, "k--", linewidth=2, markersize=4)
plt.plot((x_hat[3]+x_hat[1])/2,(y_hat[3]+y_hat[1])/2, marker=".", color='red', mec="black", markersize=12, zorder=pointzorder)
ax.add_artist(Ellipse(xy=xy, width=width*scalefactor, height=height*scalefactor, angle=angle, fill=None, alpha=1, linewidth=ld, color=ellcolor, zorder=ellzorder))

#Edge EC.
width, height, angle = ellipse_args(4,2)
xy=(X_hat[8:]+X_hat[4:6])/2
xx = np.array([x_hat[4],x_hat[2]])
yy = np.array([y_hat[4],y_hat[2]])
plt.plot(xx, yy, "k--", linewidth=2, markersize=4)
plt.plot((x_hat[4]+x_hat[2])/2,(y_hat[4]+y_hat[2])/2, marker=".", color='red', mec="black", markersize=12, zorder=pointzorder)
ax.add_artist(Ellipse(xy=xy, width=width*scalefactor, height=height*scalefactor, angle=angle, fill=None, alpha=1, linewidth=ld, color=ellcolor, zorder=ellzorder))

#Edge BC.
width, height, angle = ellipse_args(1,2)
xy=(X_hat[2:4]+X_hat[4:6])/2
xx = np.array([x_hat[1],x_hat[2]])
yy = np.array([y_hat[1],y_hat[2]])
plt.plot(xx, yy, "k--", linewidth=2, markersize=4)
plt.plot((x_hat[1]+x_hat[2])/2,(y_hat[1]+y_hat[2])/2, marker=".", color='red', mec="black", markersize=12, zorder=pointzorder)
ax.add_artist(Ellipse(xy=xy, width=width*scalefactor, height=height*scalefactor, angle=angle, fill=None, alpha=1, linewidth=ld, color=ellcolor, zorder=ellzorder))

#Plot sog.
sum_x,sum_y = 0,0
for i,el in enumerate(X_hat):
  if i%2==0: 
    sum_x += el 
  else: 
    sum_y += el 

x_mean = sum_x/v #sog x
y_mean = sum_y/v #sog y
plt.plot(x_mean, y_mean, marker=".", color='blue', mec="black", markersize=12, zorder=pointzorder)    
ax.annotate("Center of Gravity", (x_mean, y_mean), xytext=(x_mean+5,y_mean+5), zorder=pointzorder)    

plt.title("Absolute and Relative error ellipses - Minimum Internal Constraints")
plt.xlabel("X (m)")
plt.ylabel("Y (m)")
plt.show();

#Save the figure.
formatype='png'
fig.savefig("/content/sample_data/Error_Ellipses_Minimum_Internal_Constraints."+formatype, dpi=300, facecolor='w', edgecolor='w',
        orientation='portrait', papertype=None, format=formatype,
        transparent=False, bbox_inches=None, pad_inches=0.1,
        metadata=None);